name: Deploy to VPS

on:
  workflow_dispatch:  # 🔄 ТОЛЬКО ручной запуск через GitHub UI
    inputs:
      reason:
        description: 'Причина деплоя'
        required: false
        default: 'Ручной деплой'

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: 🔄 Ручной деплой
      run: |
        echo "🔄 РУЧНОЙ ДЕПЛОЙ ЗАПУЩЕН"
        echo "📝 Причина: ${{ github.event.inputs.reason }}"
        echo "👤 Запустил: ${{ github.actor }}"
        echo "🕒 Время: $(date)"
        
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to VPS
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USER }}
        key: ${{ secrets.VPS_SSH_KEY }}
        script: |
          # Деплой в домашней директории пользователя (БЕЗ SUDO!)
          cd ~/gongbu-platform || (git clone https://github.com/appletownworld/gongbu-platform.git ~/gongbu-platform && cd ~/gongbu-platform)
          
          # Принудительное обновление (решает конфликты)
          git fetch origin
          git reset --hard origin/main
          
          # Создание .env из секретов GitHub
          cat > .env << 'EOF'
          NODE_ENV=production
          PORT=3000
          
          # Database
          DATABASE_URL=postgresql://gongbu_user:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/gongbu_platform
          DB_USER=gongbu_user
          DB_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_USER=gongbu_user
          POSTGRES_DB=gongbu_platform
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          
          # Redis
          REDIS_URL=redis://redis:6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          
          # JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=7d
          
          # Telegram
          TELEGRAM_BOT_TOKEN=${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_BOT_USERNAME=gongbu_platform_bot
          TELEGRAM_WEBHOOK_URL=${{ secrets.WEBHOOK_URL }}
          TELEGRAM_WEBAPP_SECRET=${{ secrets.TELEGRAM_WEBAPP_SECRET }}
          WEBHOOK_URL=${{ secrets.WEBHOOK_URL }}
          ADMIN_USER_IDS=${{ secrets.ADMIN_USER_IDS }}
          TELEGRAM_PAYMENT_TOKEN=
          
          # URLs
          WEBAPP_URL=${{ secrets.APP_URL }}
          APP_URL=${{ secrets.APP_URL }}
          API_BASE_URL=${{ secrets.API_BASE_URL }}
          WEBSOCKET_URL=${{ secrets.WEBSOCKET_URL }}
          DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
          
          # CORS
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          
          # Payment
          STRIPE_SECRET_KEY=
          STRIPE_WEBHOOK_SECRET=
          
          # Email
          SENDGRID_API_KEY=
          EMAIL_FROM=noreply@${{ secrets.DOMAIN_NAME }}
          
          # Monitoring
          GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          
          # Services URLs (internal)
          AUTH_SERVICE_URL=http://auth-service:3001
          COURSE_SERVICE_URL=http://course-service:3002
          BOT_SERVICE_URL=http://bot-service:3003
          PAYMENT_SERVICE_URL=http://payment-service:3004
          NOTIFICATION_SERVICE_URL=http://notification-service:3005
          ANALYTICS_SERVICE_URL=http://analytics-service:3006
          EOF
          
            # Добавление пользователя в docker группу (если еще не добавлен)
            groups $USER | grep -q docker || (echo "⚠️ Пользователь не в группе docker. Добавьте: sudo usermod -aG docker $USER && exit")
            
            # Создание необходимых директорий для SSL
            mkdir -p nginx/html
            mkdir -p letsencrypt
            echo "📁 Созданы директории для SSL сертификатов"
          
          # Создание nginx.conf только если не существует (БЕЗОПАСНОСТЬ!)
          if [ ! -f nginx.conf ]; then
            echo "🔧 Создаем базовый nginx.conf (первый деплой)..."
            cat > nginx.conf << 'EOF'
          events {
              worker_connections 1024;
          }
          
          http {
              upstream web-app {
                  server web-app:3000;
              }
              
              upstream bot-service {
                  server bot-service:3003;
              }
              
              server {
                  listen 80;
                  server_name _;
                  
                  location /health {
                      return 200 'OK';
                      add_header Content-Type text/plain;
                  }
                  
                  location /api/bots {
                      proxy_pass http://bot-service;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                  }
                  
                  location /webhook {
                      proxy_pass http://bot-service;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                  }
                  
                  location / {
                      proxy_pass http://web-app;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                  }
              }
          }
          EOF
          else
            echo "✅ nginx.conf уже существует, сохраняем пользовательские настройки"
          fi
          
          # Остановка старых контейнеров
          docker-compose -f docker-compose.simple.yml down || true
          
          # Очистка системы Docker
          docker system prune -f || echo "⚠️ Docker system prune failed, continuing..."
          
          # Предварительная диагностика перед запуском
          echo "🔍 ПРЕДВАРИТЕЛЬНАЯ ДИАГНОСТИКА:"
          echo "💾 Дисковое пространство:"
          df -h /
          echo "🧠 Память:"
          free -h
          echo "🔌 Занятые порты:"
          netstat -tlnp | grep -E ':(80|443|5432|6379|3000|3001|3002|3003) ' || echo "Целевые порты свободны"
          
          # Проверка .env файла
          echo "📄 Проверка .env файла:"
          ls -la .env && echo "✅ .env файл существует" || echo "❌ .env файл отсутствует"
          
          echo "🔍 Проверка ключевых переменных окружения:"
          echo "DATABASE_URL (первые 30 символов): $(echo $DATABASE_URL | cut -c1-30)..."
          echo "JWT_SECRET установлен: $([ -n "$JWT_SECRET" ] && echo "✅ Да" || echo "❌ Нет")"
          echo "TELEGRAM_BOT_TOKEN установлен: $([ -n "$TELEGRAM_BOT_TOKEN" ] && echo "✅ Да" || echo "❌ Нет")"
          
          echo ""
          echo "🔍 СОДЕРЖИМОЕ .env ФАЙЛА (первые 50 строк, секреты скрыты):"
          head -50 .env | sed 's/\(SECRET\|TOKEN\|PASSWORD\)=.*/\1=***HIDDEN***/' || echo "Не удалось прочитать .env"
          
          echo ""
          echo "🔍 ПРОВЕРКА GITHUB SECRETS В .env:"
          echo "Строк с JWT_SECRET: $(grep -c "JWT_SECRET=" .env || echo "0")"  
          echo "Строк с TELEGRAM_BOT_TOKEN: $(grep -c "TELEGRAM_BOT_TOKEN=" .env || echo "0")"
          echo "Строк с DATABASE_URL: $(grep -c "DATABASE_URL=" .env || echo "0")"
          
          # Попытка загрузить переменные из .env файла  
          echo "🔄 Загрузка переменных из .env файла:"
          export $(cat .env | grep -v '^#' | xargs) || echo "Не удалось загрузить .env"
          
          echo "🔍 ПОВТОРНАЯ ПРОВЕРКА переменных после загрузки .env:"
          echo "DATABASE_URL установлен: $([ -n "$DATABASE_URL" ] && echo "✅ Да" || echo "❌ Нет")"
          echo "JWT_SECRET установлен: $([ -n "$JWT_SECRET" ] && echo "✅ Да" || echo "❌ Нет")"  
          echo "TELEGRAM_BOT_TOKEN установлен: $([ -n "$TELEGRAM_BOT_TOKEN" ] && echo "✅ Да" || echo "❌ Нет")"
          
          # Диагностика перед запуском 
          echo "🔍 ДИАГНОСТИКА ПЕРЕД ЗАПУСКОМ:"
          echo "✅ Docker version: $(docker --version)"
          echo "✅ Docker Compose version: $(docker-compose --version)"
          echo "📋 Environment variables check:"
          echo "  - POSTGRES_USER: ${POSTGRES_USER:-not_set}"
          echo "  - POSTGRES_DB: ${POSTGRES_DB:-not_set}" 
          echo "  - DATABASE_URL check: $(echo $DATABASE_URL | sed 's/:[^@]*@/:***@/g')"
          
          # Очистка предыдущих контейнеров (решение из devlog 19.09)
          echo "🧹 Очистка предыдущих контейнеров..."
          docker-compose -f docker-compose.simple.yml down --remove-orphans 2>/dev/null || true
          docker system prune -f || true
          
          # Запуск упрощенной системы (только существующие сервисы)
          echo "🚀 Запуск Docker Compose с детальным логированием..."
          docker-compose -f docker-compose.simple.yml up -d --build --force-recreate 2>&1 | tee build.log
          
          # Проверяем статус сборки
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
            echo "❌ ОШИБКА СБОРКИ! Показываем последние 50 строк:"
            tail -50 build.log
            exit 1
          fi
          
          # Увеличиваем время ожидания для медленных VPS
          echo "⏳ Ожидание инициализации контейнеров (30 сек)..."
          sleep 30
          
          # Проверка что контейнеры хотя бы пытались запуститься
          echo "🔍 ПРОВЕРКА СТАТУСА КОНТЕЙНЕРОВ:"
          docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || echo "Не удалось получить статус контейнеров"
          
          # Если контейнеры не запустились - показываем детальные логи
          RUNNING_CONTAINERS=$(docker ps --format "{{.Names}}" | wc -l)
          echo "📊 Количество запущенных контейнеров: $RUNNING_CONTAINERS"
          
          if [ "$RUNNING_CONTAINERS" -lt 2 ]; then
            echo "⚠️ МАЛО КОНТЕЙНЕРОВ ЗАПУЩЕНО! Показываем детальные логи сборки:"
            echo "📋 Последние 100 строк build.log:"
            tail -100 build.log || echo "build.log не найден"
            
            echo ""
            echo "📋 Docker Compose логи для всех сервисов:"
            docker-compose -f docker-compose.simple.yml logs --tail=50 || echo "Не удалось получить compose логи"
            
            echo ""
            echo "📋 Логи отдельных контейнеров:"
            for container in $(docker ps -a --format "{{.Names}}"); do
              echo "--- Логи $container ---"
              docker logs --tail=20 "$container" 2>&1 || echo "Не удалось получить логи $container"
              echo ""
            done
          fi
          
          echo ""
          echo "🔍 DOCKER COMPOSE статус:"
          docker-compose -f docker-compose.simple.yml ps || echo "docker-compose ps не удался"
          
          # Ожидание готовности системы
          echo "⏳ Ожидание запуска системы..."
          for i in {1..30}; do
            if docker-compose -f docker-compose.simple.yml ps | grep -q "Up"; then
              echo "✅ Контейнеры запущены"
              break
            fi
            echo "⏳ Ожидание запуска контейнеров ($i/30)..."
            sleep 5
          done
          
          # Проверка статуса всех сервисов
          echo "📊 Статус сервисов:"
          docker-compose -f docker-compose.simple.yml ps
          
          # Проверка логов при ошибках
          if ! docker-compose -f docker-compose.simple.yml ps | grep -q "Up"; then
            echo "❌ Есть проблемы с контейнерами!"
            
            echo ""
            echo "🔍 ДИАГНОСТИКА СИСТЕМЫ:"
            echo "💾 Дисковое пространство:"
            df -h / || echo "Не удалось проверить диск"
            
            echo "🧠 Память:"
            free -h || echo "Не удалось проверить память"
            
            echo "🐳 Запущенные контейнеры:"
            docker ps -a || echo "Не удалось получить список контейнеров"
            
            echo "📝 ДЕТАЛЬНЫЕ ЛОГИ КАЖДОГО СЕРВИСА:"
            
            echo ""
            echo "🗄️ PostgreSQL логи:"
            docker-compose -f docker-compose.simple.yml logs --tail=30 postgres || echo "PostgreSQL логи недоступны"
            
            echo ""
            echo "🔑 Auth Service логи:"
            docker-compose -f docker-compose.simple.yml logs --tail=20 auth-service || echo "Auth Service логи недоступны"
            
            echo ""
            echo "📚 Course Service логи:"  
            docker-compose -f docker-compose.simple.yml logs --tail=20 course-service || echo "Course Service логи недоступны"
            
            echo ""
            echo "🤖 Bot Service логи:"
            docker-compose -f docker-compose.simple.yml logs --tail=20 bot-service || echo "Bot Service логи недоступны"
            
            echo ""
            echo "🌐 Web App логи:"
            docker-compose -f docker-compose.simple.yml logs --tail=20 web-app || echo "Web App логи недоступны"
            
            echo ""
            echo "🔄 Redis логи:"
            docker-compose -f docker-compose.simple.yml logs --tail=10 redis || echo "Redis логи недоступны"
            
            echo ""
            echo "🌍 Nginx логи:"
            docker-compose -f docker-compose.simple.yml logs --tail=15 nginx || echo "Nginx логи недоступны"
            
            echo ""
            echo "📊 ОБЩИЕ ЛОГИ (последние 100 строк):"
            docker-compose -f docker-compose.simple.yml logs --tail=100
          else
            echo "✅ Все контейнеры запущены успешно!"
            
            # Дополнительная диагностика сети
            echo "🔍 ДИАГНОСТИКА СЕТИ:"
            echo "📍 Внешний IP VPS:"
            curl -s ifconfig.me || echo "Не удалось получить внешний IP"
            
            echo "🔌 Открытые порты:"
            netstat -tlnp 2>/dev/null | grep -E ':80 |:443 ' || echo "Порты 80/443 не слушаются"
            
            echo "🏥 Локальный health check:"
            curl -f http://localhost:80/health --max-time 5 2>/dev/null && echo "✅ Локальный health OK" || echo "❌ Локальный health не работает"
            
            echo "🌐 Nginx статус:"
            docker-compose -f docker-compose.simple.yml logs nginx --tail=10
          fi

    - name: Wait for HTTPS (smart retry)
      continue-on-error: true
      run: |
        echo "🔍 Ожидание готовности HTTPS endpoint..."
        APP_URL="${{ secrets.APP_URL }}"
        DOMAIN_URL="${APP_URL:-https://gongbu.appletownworld.com}"
        
        curl -fsS "$DOMAIN_URL/health" \
          --retry 20 --retry-all-errors --retry-delay 5 --max-time 10 \
          --retry-connrefused || {
          echo "❌ HTTPS health check не удался, пробуем HTTP..."
          HTTP_URL=$(echo "$DOMAIN_URL" | sed 's/https:/http:/')
          curl -fsS "$HTTP_URL/health" \
            --retry 10 --retry-all-errors --retry-delay 3 --max-time 8 || {
            echo ""
            echo "🚨 ВНИМАНИЕ: Health check не прошел!"
            echo "📋 ЧТО ПРОВЕРИТЬ НА VPS:"
            echo "1. sudo ufw allow 80/tcp && sudo ufw allow 443/tcp"  
            echo "2. nslookup $DOMAIN_URL (DNS настроен правильно?)"
            echo "3. curl ifconfig.me (правильный IP в DNS?)"
            echo "4. docker-compose -f ~/gongbu-platform/docker-compose.simple.yml ps"
            echo "5. curl http://localhost:80/health (работает локально?)"
            echo ""
            echo "📚 Подробная диагностика: https://github.com/${{ github.repository }}/blob/main/TROUBLESHOOTING-NETWORK.md"
            echo ""
            echo "🏗️ КОНТЕЙНЕРЫ СОБРАНЫ УСПЕШНО! Это проблема сетевой доступности."
            exit 1
          }
        }

    - name: Notify Telegram
      if: always()
      uses: appleboy/telegram-action@master
      with:
        to: ${{ secrets.TELEGRAM_CHAT_ID }}
        token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        message: |
          🚀 Deploy Status: ${{ job.status }}
          📦 Repository: gongbu-platform
          🌐 Environment: Production
          🔗 URL: ${{ secrets.API_BASE_URL }}